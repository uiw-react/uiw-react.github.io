{"version":3,"sources":["../../node_modules/@babel/traverse/lib/index.js","../../node_modules/@babel/traverse/lib/path/index.js","../../node_modules/@babel/traverse/lib/cache.js","../../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../../node_modules/@babel/traverse/lib/scope/index.js","../../node_modules/@babel/traverse/lib/scope/binding.js","../../node_modules/@babel/traverse/lib/visitors.js","../../node_modules/@babel/traverse/lib/context.js","../../node_modules/@babel/traverse/node_modules/debug/src/browser.js","../../node_modules/@babel/traverse/node_modules/debug/src/common.js","../../node_modules/@babel/traverse/node_modules/ms/index.js","../../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../../node_modules/@babel/traverse/lib/path/ancestry.js","../../node_modules/@babel/traverse/lib/path/inference/index.js","../../node_modules/@babel/traverse/lib/path/inference/inferers.js","../../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../../node_modules/@babel/traverse/lib/path/replacement.js","../../node_modules/@babel/traverse/lib/path/evaluation.js","../../node_modules/@babel/traverse/lib/path/conversion.js","../../node_modules/@babel/traverse/lib/path/introspection.js","../../node_modules/@babel/traverse/lib/path/context.js","../../node_modules/@babel/traverse/lib/path/removal.js","../../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../../node_modules/@babel/traverse/lib/path/modification.js","../../node_modules/@babel/traverse/lib/path/lib/hoister.js","../../node_modules/@babel/traverse/lib/path/family.js","../../node_modules/@babel/traverse/lib/path/comments.js","../../node_modules/@babel/traverse/lib/hub.js"],"names":["Object","defineProperty","exports","value","enumerable","get","_hub","default","_path","_scope","visitors","_context","require","_t","cache","VISITOR_KEYS","removeProperties","traverseFast","traverse","parent","opts","scope","state","parentPath","noScope","type","Error","explode","node","_default","hasDenylistedType","path","has","stop","verify","cheap","enter","skipKeys","keys","context","key","visit","clearNode","delete","tree","hasType","denylistTypes","includes","denylist","SHOULD_STOP","SHOULD_SKIP","REMOVED","virtualTypes","_debug","_index","t","_cache","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","validate","debug","NodePath","hub","this","contexts","_traverseFlags","container","listKey","data","isScope","val","create","def","undefined","msg","SyntaxError","buildError","visitor","parts","inList","unshift","join","message","enabled","getPathLocation","code","v","targetNode","paths","Map","set","setup","assign","prototype","TYPES","typeKey","fn","TypeError","indexOf","push","virtualType","checkPath","clear","clearPath","clearScope","WeakMap","Var","User","Statement","SpreadProperty","Scope","RestProperty","ReferencedMemberExpression","ReferencedIdentifier","Referenced","Pure","NumericLiteralTypeAnnotation","Generated","ForAwaitStatement","Flow","Expression","ExistentialTypeParam","BlockScoped","BindingIdentifier","isBinding","isBlockScoped","isExportDeclaration","isExpression","isFlow","isForStatement","isForXStatement","isIdentifier","isImportDeclaration","isImportSpecifier","isJSXIdentifier","isJSXMemberExpression","isMemberExpression","isReferenced","isStatement","isVar","isVariableDeclaration","isCompatTag","react","types","name","grandparent","left","init","isReferencedIdentifier","loc","isUser","isPure","importKind","exportKind","isObjectPattern","isObjectExpression","await","_renamer","_binding","_globals","NOT_LOCAL_BINDING","callExpression","cloneNode","getBindingIdentifiers","identifier","isArrayExpression","isBinary","isClass","isClassBody","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isFunctionDeclaration","isLiteral","isMethod","isModuleDeclaration","isModuleSpecifier","isProperty","isPureish","isSuper","isTaggedTemplateExpression","isTemplateLiteral","isThisExpression","isUnaryExpression","matchesPattern","memberExpression","numericLiteral","toIdentifier","unaryExpression","variableDeclaration","variableDeclarator","gatherNodeParts","source","specifiers","length","declaration","local","object","property","callee","properties","argument","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","ForStatement","declar","getFunctionParent","getProgramParent","registerBinding","Declaration","registerDeclaration","ImportDeclaration","getBlockParent","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","binding","getBinding","reference","declarations","decl","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","bindings","CatchClause","Function","params","param","isFunctionExpression","ClassExpression","uid","block","labels","inited","globals","uids","crawling","cached","_parent","isKey","generateUidIdentifier","generateUid","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","defaultName","slice","generateUidBasedOnNode","constant","dontPush","isStatic","generateUidIdentifierBasedOnNode","kind","oldName","newName","rename","map","sep","repeat","console","log","violations","arrayLikeIsIterable","isGenericType","helperName","args","addHelper","getLabel","label","isLabeledStatement","registerLabel","declare","specifier","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","constantsOnly","superClass","body","method","right","elements","elem","prop","computed","tag","quasi","expressions","crawl","programParent","_exploded","typeVisitors","addGlobal","ref","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","getData","unshiftContainer","setData","declarator","pop","isFunctionParent","isBlockParent","kinds","getBindingIdentifier","previousPath","_previousPath","isArrowFunctionExpression","_this$getBinding","noGlobals","hasOwnBinding","parentHasBinding","hasUid","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","builtin","Binding","referencePaths","referenced","clearValue","hasDeoptedValue","hasValue","merge","states","wrapper","rootVisitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","DEPRECATED_KEYS","FLIPPED_ALIAS_KEYS","nodeType","shouldIgnoreKey","split","fns","__esModule","obj","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","aliases","deprecatedKey","trace","alias","existing","_verified","validateVisitorMethods","visitorKey","concat","oldVisitor","newVisitor","Array","isArray","newFn","call","toString","apply","arguments","dest","src","TraversalContext","queue","priorityQueue","notPriority","shouldVisit","visitQueue","visited","WeakSet","resync","pushContext","add","popContext","nodes","visitMultiple","visitSingle","formatArgs","useColors","module","humanize","diff","c","color","splice","index","lastC","match","save","namespaces","storage","setItem","removeItem","error","load","r","getItem","process","DEBUG","window","__nwjs","navigator","userAgent","toLowerCase","document","documentElement","style","WebkitAppearance","firebug","exception","table","parseInt","RegExp","$1","localStorage","localstorage","destroy","warned","warn","colors","formatters","j","JSON","stringify","env","createDebug","prevTime","namespacesCache","enabledCache","enableOverride","self","curr","Number","Date","ms","prev","coerce","format","formatter","logFn","selectColor","extend","configurable","delimiter","newDebug","toNamespace","regexp","substring","stack","disable","names","skips","enable","len","substr","test","forEach","hash","charCodeAt","Math","abs","s","m","h","d","w","y","plural","msAbs","n","isPlural","round","options","str","String","exec","parseFloat","parse","isFinite","long","fmtLong","fmtShort","_helperSplitExportDeclaration","renameVisitor","assignmentExpression","toExpression","bindingIdentifierEquals","skip","skipKey","skipAllButComputedMethodKey","Renamer","parentDeclar","maybeExportDeclar","find","isDeclaration","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","cases","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","callback","findParent","getAncestry","getDeepestCommonAncestorFrom","filter","lastCommonIndex","lastCommon","minDepth","Infinity","ancestries","ancestry","first","depthLoop","shouldMatch","getEarliestCommonAncestorFrom","deepest","earliest","parentKey","p","getStatementParent","isFile","inType","candidateTypes","isAncestor","maybeDescendant","isDescendant","maybeAncestor","_getTypeAnnotation","isVariableDeclarator","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","anyTypeAnnotation","voidTypeAnnotation","typeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","validParent","getTypeAnnotation","baseTypeStrictlyMatches","rightArg","isAnyTypeAnnotation","isFlowBaseAnnotation","couldBeBaseType","isUnionTypeAnnotation","type2","_isBaseType","isTypeAnnotation","isBaseType","baseName","soft","genericName","isGenericTypeAnnotation","isBooleanTypeAnnotation","isEmptyTypeAnnotation","isMixedTypeAnnotation","isNumberTypeAnnotation","isStringTypeAnnotation","isVoidTypeAnnotation","ArrayExpression","BinaryExpression","NUMBER_BINARY_OPERATORS","numberTypeAnnotation","BOOLEAN_BINARY_OPERATORS","booleanTypeAnnotation","unionTypeAnnotation","BooleanLiteral","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","ConditionalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ClassDeclaration","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","genericTypeAnnotation","_infererReference","LogicalExpression","NewExpression","NullLiteral","nullLiteralTypeAnnotation","NumericLiteral","ObjectExpression","ParenthesizedExpression","RegExpLiteral","RestElement","SequenceExpression","StringLiteral","TaggedTemplateExpression","TemplateLiteral","TypeCastExpression","NUMBER_UNARY_OPERATORS","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","VariableDeclarator","_type","isCallExpression","buildMatchMemberExpression","resolve","is","returnType","functionConstantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","violation","getTypeAnnotationBindingConstantViolations","BOOLEAN_NUMBER_BINARY_OPERATORS","createTypeAnnotationBasedOnTypeof","functions","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","target","typeofPath","typePath","typeValue","isIfStatement","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","_replaceWith","_pathCache$get2","replaceExpressionWithStatements","nodesAsSequenceExpression","toSequenceExpression","replaceWith","functionParent","isParentAsync","isParentGenerator","arrowFunctionExpression","blockStatement","_helperHoistVariables","completionRecords","getCompletionRecords","isExpressionStatement","loop","generateDeclaredUidIdentifier","pushContainer","returnStatement","arrowFunctionToExpression","newCallee","needToAwaitFunction","FUNCTION_TYPES","needToYieldFunction","awaitExpression","yieldExpression","replaceInline","_verifyNodeList","_containerInsertAfter","remove","replaceWithMultiple","replacement","removed","_index2","nodePath","isNodeType","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","expressionStatement","oldNode","inheritsComments","removeComments","setScope","requeue","_pathCache$get","inheritLeadingComments","inheritTrailingComments","insertAfter","replaceWithSourceString","_parser","err","_codeFrame","codeFrameColumns","start","line","column","evaluate","confident","deoptPath","seen","evaluateCached","deopt","evaluateTruthy","res","VALID_CALLEES","INVALID_METHODS","resolved","item","isSequenceExpression","exprs","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","evaluateQuasis","quasis","testResult","isExpressionWrapper","end","NaN","prefix","arg","arr","elems","elemValue","props","isObjectMethod","isSpreadElement","wasConfident","leftConfident","rightConfident","pow","func","global","_evaluate","raw","cooked","expr","allowInsertArrow","specCompliant","noNewArrows","buildCodeFrameError","hoistFunctionEnvironment","thisBinding","fnPath","checkBinding","objectExpression","thisExpression","_helperFunctionName","arrowFunctionToShadowed","bodyNode","statements","stringPath","toComputedKey","stringLiteral","unwrapFunctionEnvironment","_helperEnvironmentVisitor","_visitors","binaryExpression","conditionalExpression","jsxIdentifier","metaProperty","restElement","sequenceExpression","spreadElement","_super","super","getSuperCallsVisitor","child","allSuperCalls","arrowParent","thisEnvFn","isClassProperty","static","isClassPrivateProperty","inConstructor","isClassMethod","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","superBinding","getSuperBinding","superCall","argumentsBinding","buildUndefinedNode","argumentsChild","argsRef","newTargetBinding","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","assignmentPath","op","tmp","isUpdateExpression","updateExpr","computedKey","assignSuperThisVisitor","supers","argsBinding","propName","fnBody","argsList","valueIdent","cacheKey","getScopeInformationVisitor","ThisExpression","JSXIdentifier","isJSXOpeningElement","MemberExpression","Identifier","MetaProperty","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","allStatus","executionOrderCheckedNodes","_resolve","dangerous","ret","isTypeCastExpression","targetKey","targetName","isnt","isNaN","isFor","equals","getSource","getCode","isCompletionRecord","allowInsideFunction","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","isType","isStatementOrBlock","STATEMENT_OR_BLOCK_KEYS","pattern","allowPartial","_matchesPattern","referencesImport","moduleSource","importName","isOptionalMemberExpression","isImportDefaultSpecifier","isImportNamespaceSpecifier","imported","willIMaybeExecuteBefore","isExecutionUncertain","maxIndex","_call","then","_getQueueContexts","_resyncKey","setKey","_resyncList","newContainer","_resyncParent","_resyncRemoved","_markRemoved","isBlacklisted","isDenylisted","_this$opts$denylist","blacklist","setContext","pathToQueue","maybeQueue","_this$node","getScope","shouldSkip","currentContext","shouldStop","restoreContext","_assertUnremoved","_callRemovalHooks","_removalHooks","hooks","_remove","updateSiblingKeys","_removeFromScope","removeBinding","_this$opts","shareCommentsWithSiblings","isWhile","isSwitchCase","_containerInsert","from","to","getSibling","_containerInsertBefore","hoist","hoister","_hoister","run","nodes_","isJSXElement","assertExpression","temp","shouldInsertCurrentNode","insertBefore","verifiedNodes","fromIndex","incrementBy","_t2","jsxExpressionContainer","referenceVisitor","breakOnScopePaths","mutableBinding","PathHoister","scopes","attachAfter","isCompatibleScope","_getAttachmentPath","targetScope","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","getCompatibleScopes","attachTo","getAttachmentPath","attached","children","_getKey","_","_getPattern","part","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","getBindingIdentifierPaths","duplicates","outerOnly","search","shift","_getBindingIdentifiers","_ids","_getCompletionRecords","canHaveBreak","shouldPopulateBreak","inCaseClause","getNextSibling","getOpposite","getOuterBindingIdentifierPaths","_getOuterBindingIdentifiers","getPrevSibling","addCompletionRecords","records","normalCompletionToBreak","completions","replaceBreakStatementInBreakCompletion","reachable","isBreakStatement","getStatementListCompletion","lastNormalCompletions","newContext","statementCompletions","some","pathCompletions","isDoExpression","isTryStatement","caseCompletions","normalCompletions","breakCompletions","completionRecordForSwitch","BreakCompletion","NormalCompletion","addComment","content","_addComment","addComments","comments","_addComments","trailing","trailingComments","leading","leadingComments","next","hasPrev","Boolean","hasNext","Hub"],"mappings":"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","file":"static/js/vendors-runtime-traverse.40de0277.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nexports.visitors = exports.default = void 0;\n\nvar _context = require(\"./context\");\n\nvar visitors = require(\"./visitors\");\n\nexports.visitors = visitors;\n\nvar _t = require(\"@babel/types\");\n\nvar cache = require(\"./cache\");\n\nvar _path = require(\"./path\");\n\nvar _scope = require(\"./scope\");\n\nvar _hub = require(\"./hub\");\n\nconst {\n  VISITOR_KEYS,\n  removeProperties,\n  traverseFast\n} = _t;\n\nfunction traverse(parent, opts = {}, scope, state, parentPath) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\nvar _default = traverse;\nexports.default = _default;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;\n\nvar virtualTypes = require(\"./lib/virtual-types\");\n\nvar _debug = require(\"debug\");\n\nvar _index = require(\"../index\");\n\nvar _scope = require(\"../scope\");\n\nvar _t = require(\"@babel/types\");\n\nvar t = _t;\n\nvar _cache = require(\"../cache\");\n\nvar _generator = require(\"@babel/generator\");\n\nvar NodePath_ancestry = require(\"./ancestry\");\n\nvar NodePath_inference = require(\"./inference\");\n\nvar NodePath_replacement = require(\"./replacement\");\n\nvar NodePath_evaluation = require(\"./evaluation\");\n\nvar NodePath_conversion = require(\"./conversion\");\n\nvar NodePath_introspection = require(\"./introspection\");\n\nvar NodePath_context = require(\"./context\");\n\nvar NodePath_removal = require(\"./removal\");\n\nvar NodePath_modification = require(\"./modification\");\n\nvar NodePath_family = require(\"./family\");\n\nvar NodePath_comments = require(\"./comments\");\n\nconst {\n  validate\n} = _t;\n\nconst debug = _debug(\"babel\");\n\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isBinding,\n  isBlockScoped,\n  isExportDeclaration,\n  isExpression,\n  isFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isReferenced,\n  isScope,\n  isStatement,\n  isVar,\n  isVariableDeclaration,\n  react\n} = _t;\nconst {\n  isCompatTag\n} = react;\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n      if (isJSXIdentifier(node, opts)) {\n        if (isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return isMemberExpression(node) && isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return isIdentifier(node) && isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (isStatement(node)) {\n      if (isVariableDeclaration(node)) {\n        if (isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (isFlow(node)) {\n      return true;\n    } else if (isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar _t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMethod,\n  isModuleDeclaration,\n  isModuleSpecifier,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n\n    if (declar.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        binding == null ? void 0 : binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding == null ? void 0 : binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (isThisExpression(node) || isSuper(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return unaryExpression(\"void\", numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTaggedTemplateExpression(node)) {\n      return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\" && binding.kind !== \"local\") {} else {\n          return binding;\n        }\n      } else if (!binding && name === \"arguments\" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n        break;\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.merge = merge;\nexports.verify = verify;\n\nvar virtualTypes = require(\"./path/lib/virtual-types\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  DEPRECATED_KEYS,\n  FLIPPED_ALIAS_KEYS,\n  TYPES\n} = _t;\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = require(\"./path\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  VISITOR_KEYS\n} = _t;\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = VISITOR_KEYS[node.type];\n    if (!(keys != null && keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = require(\"../binding\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  VISITOR_KEYS,\n  assignmentExpression,\n  identifier,\n  toExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(variableDeclaration(\"let\", [variableDeclarator(identifier(this.newName), toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: identifier(this.newName)\n    });\n    path.replaceWith(assignmentExpression(\"=\", identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.find = find;\nexports.findParent = findParent;\nexports.getAncestry = getAncestry;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.inType = inType;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\n\nvar _t = require(\"@babel/types\");\n\nvar _index = require(\"./index\");\n\nconst {\n  VISITOR_KEYS\n} = _t;\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType(...candidateTypes) {\n  let path = this;\n\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.couldBeBaseType = couldBeBaseType;\nexports.getTypeAnnotation = getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.isGenericType = isGenericType;\n\nvar inferers = require(\"./inferers\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  anyTypeAnnotation,\n  isAnyTypeAnnotation,\n  isBooleanTypeAnnotation,\n  isEmptyTypeAnnotation,\n  isFlowBaseAnnotation,\n  isGenericTypeAnnotation,\n  isIdentifier,\n  isMixedTypeAnnotation,\n  isNumberTypeAnnotation,\n  isStringTypeAnnotation,\n  isTypeAnnotation,\n  isUnionTypeAnnotation,\n  isVoidTypeAnnotation,\n  stringTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || anyTypeAnnotation();\n  if (isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return anyTypeAnnotation();\n      }\n\n      return voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) != null && _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (isAnyTypeAnnotation(type)) return true;\n\n  if (isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n\n  return false;\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return isGenericTypeAnnotation(type) && isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayExpression = ArrayExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.BooleanLiteral = BooleanLiteral;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\nexports.LogicalExpression = LogicalExpression;\nexports.NewExpression = NewExpression;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.RestElement = RestElement;\nexports.SequenceExpression = SequenceExpression;\nexports.StringLiteral = StringLiteral;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.TypeCastExpression = TypeCastExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.VariableDeclarator = VariableDeclarator;\n\nvar _t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nconst {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  createFlowUnionType,\n  createTSUnionType,\n  createUnionTypeAnnotation,\n  genericTypeAnnotation,\n  identifier,\n  isTSTypeAnnotation,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return stringTypeAnnotation();\n    }\n\n    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createFlowUnionType,\n  createTSUnionType,\n  createTypeAnnotationBasedOnTypeof,\n  createUnionTypeAnnotation,\n  isTSTypeAnnotation,\n  numberTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations.push(...functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (isTSTypeAnnotation(types[0]) && createTSUnionType) {\n    return createTSUnionType(types);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(types);\n  }\n\n  return createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (isTSTypeAnnotation(types[0]) && createTSUnionType) {\n      return {\n        typeAnnotation: createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (createFlowUnionType) {\n      return {\n        typeAnnotation: createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\nexports.replaceWith = replaceWith;\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar _t = require(\"@babel/types\");\n\nvar _helperHoistVariables = require(\"@babel/helper-hoist-variables\");\n\nconst {\n  FUNCTION_TYPES,\n  arrowFunctionExpression,\n  assignmentExpression,\n  awaitExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  identifier,\n  inheritLeadingComments,\n  inheritTrailingComments,\n  inheritsComments,\n  isExpression,\n  isProgram,\n  isStatement,\n  removeComments,\n  returnStatement,\n  toSequenceExpression,\n  validate,\n  yieldExpression\n} = _t;\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  inheritLeadingComments(nodes[0], this.node);\n  inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    inheritsComments(replacement, oldNode);\n    removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    validate(this.parent, this.key, [node]);\n  } else {\n    validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);\n\n  if (nodesAsSequenceExpression) {\n    return this.replaceWith(nodesAsSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.is(\"generator\");\n  const container = arrowFunctionExpression([], blockStatement(nodes));\n  this.replaceWith(callExpression(container, []));\n  const callee = this.get(\"callee\");\n  (0, _helperHoistVariables.default)(callee.get(\"body\"), id => {\n    this.scope.push({\n      id\n    });\n  }, \"var\");\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", returnStatement(cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(assignmentExpression(\"=\", cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(returnStatement(path.node.expression));\n    }\n  }\n\n  callee.arrowFunctionToExpression();\n  const newCallee = callee;\n\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", FUNCTION_TYPES);\n\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get(\"callee.body\").node, \"YieldExpression\", FUNCTION_TYPES);\n\n  if (needToAwaitFunction) {\n    newCallee.set(\"async\", true);\n\n    if (!needToYieldFunction) {\n      this.replaceWith(awaitExpression(this.node));\n    }\n  }\n\n  if (needToYieldFunction) {\n    newCallee.set(\"generator\", true);\n    this.replaceWith(yieldExpression(this.node, true));\n  }\n\n  return newCallee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluate = evaluate;\nexports.evaluateTruthy = evaluateTruthy;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.ensureBlock = ensureBlock;\nexports.toComputedKey = toComputedKey;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\n\nvar _t = require(\"@babel/types\");\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _visitors = require(\"../visitors\");\n\nconst {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super: _super,\n  thisExpression,\n  toExpression,\n  unaryExpression\n} = _t;\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const {\n    thisBinding,\n    fnPath: fn\n  } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  fn.ensureBlock();\n  fn.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\"body\", expressionStatement(callExpression(this.hub.addHelper(\"newArrowCheck\"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier(\"bind\")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n  }\n}\n\nconst getSuperCallsVisitor = (0, _visitors.merge)([{\n  CallExpression(child, {\n    allSuperCalls\n  }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  let arrowParent;\n  let thisEnvFn = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      var _arrowParent;\n\n      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;\n      return false;\n    }\n\n    return p.isFunction() || p.isProgram() || p.isClassProperty({\n      static: false\n    }) || p.isClassPrivateProperty({\n      static: false\n    });\n  });\n  const inConstructor = thisEnvFn.isClassMethod({\n    kind: \"constructor\"\n  });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));\n      thisEnvFn = fnPath.get(\"callee\");\n      fnPath = thisEnvFn.get(\"body\");\n    } else {\n      throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n    }\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, {\n      allSuperCalls\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", args()), stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => metaProperty(identifier(\"new\"), identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return {\n    thisBinding,\n    fnPath\n  };\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(memberExpression(superProp.node.object, assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(binaryExpression(op, memberExpression(superProp.node.object, identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(binaryExpression(op, memberExpression(superProp.node.object, identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [assignmentExpression(\"=\", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(\"=\", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(\"+\", identifier(tmp.name), numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nconst assignSuperThisVisitor = (0, _visitors.merge)([{\n  CallExpression(child, {\n    supers,\n    thisBinding\n  }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n    child.replaceWithMultiple([child.node, assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\"))]);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nconst getScopeInformationVisitor = (0, _visitors.merge)([{\n  ThisExpression(child, {\n    thisPaths\n  }) {\n    thisPaths.push(child);\n  },\n\n  JSXIdentifier(child, {\n    thisPaths\n  }) {\n    if (child.node.name !== \"this\") return;\n\n    if (!child.parentPath.isJSXMemberExpression({\n      object: child.node\n    }) && !child.parentPath.isJSXOpeningElement({\n      name: child.node\n    })) {\n      return;\n    }\n\n    thisPaths.push(child);\n  },\n\n  CallExpression(child, {\n    superCalls\n  }) {\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n\n  MemberExpression(child, {\n    superProps\n  }) {\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n\n  Identifier(child, {\n    argumentsPaths\n  }) {\n    if (!child.isReferencedIdentifier({\n      name: \"arguments\"\n    })) return;\n    let curr = child.scope;\n\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while (curr = curr.parent);\n\n    argumentsPaths.push(child);\n  },\n\n  MetaProperty(child, {\n    newTargetPaths\n  }) {\n    if (!child.get(\"meta\").isIdentifier({\n      name: \"new\"\n    })) return;\n    if (!child.get(\"property\").isIdentifier({\n      name: \"target\"\n    })) return;\n    newTargetPaths.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports._resolve = _resolve;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.equals = equals;\nexports.getSource = getSource;\nexports.has = has;\nexports.is = void 0;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.isNodeType = isNodeType;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.matchesPattern = matchesPattern;\nexports.referencesImport = referencesImport;\nexports.resolve = resolve;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  STATEMENT_OR_BLOCK_KEYS,\n  VISITOR_KEYS,\n  isBlockStatement,\n  isExpression,\n  isIdentifier,\n  isLiteral,\n  isStringLiteral,\n  isType,\n  matchesPattern: _matchesPattern\n} = _t;\n\nfunction matchesPattern(pattern, allowPartial) {\n  return _matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) {\n    if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {\n      value: importName\n    }) : this.node.property.name === importName)) {\n      const object = this.get(\"object\");\n      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, \"*\");\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    const body = path.isFunction() ? path.node.body : path.node;\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._call = _call;\nexports._getQueueContexts = _getQueueContexts;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncParent = _resyncParent;\nexports._resyncRemoved = _resyncRemoved;\nexports.call = call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.requeue = requeue;\nexports.resync = resync;\nexports.setContext = setContext;\nexports.setKey = setKey;\nexports.setScope = setScope;\nexports.setup = setup;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.visit = visit;\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction restoreContext(path, context) {\n  if (path.context !== context) {\n    path.context = context;\n    path.state = context.state;\n    path.opts = context.opts;\n  }\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  const currentContext = this.context;\n\n  if (this.shouldSkip || this.call(\"enter\")) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  restoreContext(this, currentContext);\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  restoreContext(this, currentContext);\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  if (this.key === \"key\" && path.isMethod()) path = path.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  ;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._assertUnremoved = _assertUnremoved;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._markRemoved = _markRemoved;\nexports._remove = _remove;\nexports._removeFromScope = _removeFromScope;\nexports.remove = remove;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = require(\"./index\");\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._containerInsert = _containerInsert;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._verifyNodeList = _verifyNodeList;\nexports.hoist = hoist;\nexports.insertAfter = insertAfter;\nexports.insertBefore = insertBefore;\nexports.pushContainer = pushContainer;\nexports.unshiftContainer = unshiftContainer;\nexports.updateSiblingKeys = updateSiblingKeys;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isExpression\n} = _t;\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return isExpression(node) ? expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(expressionStatement(assignmentExpression(\"=\", cloneNode(temp), node)));\n      nodes.push(expressionStatement(cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _t = require(\"@babel/types\");\n\nvar _t2 = _t;\nconst {\n  react\n} = _t;\nconst {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator\n} = _t2;\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.get = get;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getNextSibling = getNextSibling;\nexports.getOpposite = getOpposite;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getPrevSibling = getPrevSibling;\nexports.getSibling = getSibling;\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  getBindingIdentifiers: _getBindingIdentifiers,\n  getOuterBindingIdentifiers: _getOuterBindingIdentifiers,\n  isDeclaration,\n  numericLiteral,\n  unaryExpression\n} = _t;\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\n\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, records, context) {\n  if (path) {\n    records.push(..._getCompletionRecords(path, context));\n  }\n\n  return records;\n}\n\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n\n    const caseCompletions = _getCompletionRecords(casePath, context);\n\n    const normalCompletions = [];\n    const breakCompletions = [];\n\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n\n    records.push(...breakCompletions);\n  }\n\n  records.push(...lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(unaryExpression(\"void\", numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(paths, context) {\n  const completions = [];\n\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n        newContext.shouldPopulateBreak = true;\n      } else {\n        newContext.shouldPopulateBreak = false;\n      }\n\n      const statementCompletions = _getCompletionRecords(path, newContext);\n\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions.push(...lastNormalCompletions);\n\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions.push(...statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions.push(...statementCompletions);\n\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n\n        break;\n      }\n\n      if (i === paths.length - 1) {\n        completions.push(...statementCompletions);\n      } else {\n        lastNormalCompletions = [];\n\n        for (let i = 0; i < statementCompletions.length; i++) {\n          const c = statementCompletions[i];\n\n          if (c.type === BREAK_COMPLETION) {\n            completions.push(c);\n          }\n\n          if (c.type === NORMAL_COMPLETION) {\n            lastNormalCompletions.push(c);\n          }\n        }\n      }\n    }\n  } else if (paths.length) {\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n\n      if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {\n        completions.push(...pathCompletions);\n        break;\n      }\n    }\n  }\n\n  return completions;\n}\n\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    return getStatementListCompletion(path.get(\"body\"), context);\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    return completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    return getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    });\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n\n  return records.map(r => r.path);\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return _getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return _getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  const search = [path];\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = _getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (isDeclaration(declaration)) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child)) {\n          search.push(...child);\n        } else if (child.node) {\n          search.push(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addComment = addComment;\nexports.addComments = addComments;\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  addComment: _addComment,\n  addComments: _addComments\n} = _t;\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  _addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  _addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;"],"sourceRoot":""}