{"version":3,"sources":["../../../node_modules/@babel/traverse/lib/index.js","../../../node_modules/@babel/traverse/lib/path/index.js","../../../node_modules/@babel/traverse/lib/cache.js","../../../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../../../node_modules/@babel/traverse/lib/scope/index.js","../../../node_modules/@babel/traverse/lib/scope/binding.js","../../../node_modules/@babel/traverse/lib/context.js","../../../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../../../node_modules/@babel/traverse/lib/path/ancestry.js","../../../node_modules/@babel/traverse/lib/path/inference/index.js","../../../node_modules/@babel/traverse/lib/path/inference/inferers.js","../../../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../../../node_modules/@babel/traverse/lib/path/replacement.js","../../../node_modules/@babel/traverse/lib/path/evaluation.js","../../../node_modules/@babel/traverse/lib/path/conversion.js","../../../node_modules/@babel/traverse/lib/path/introspection.js","../../../node_modules/@babel/traverse/lib/path/context.js","../../../node_modules/@babel/traverse/lib/path/removal.js","../../../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../../../node_modules/@babel/traverse/lib/path/modification.js","../../../node_modules/@babel/traverse/lib/path/lib/hoister.js","../../../node_modules/@babel/traverse/lib/path/family.js","../../../node_modules/@babel/traverse/lib/path/comments.js","../../../node_modules/@babel/traverse/node_modules/debug/src/browser.js","../../../node_modules/@babel/traverse/node_modules/debug/src/common.js","../../../node_modules/@babel/traverse/node_modules/ms/index.js","../../../node_modules/@babel/traverse/lib/visitors.js","../../../node_modules/@babel/traverse/lib/hub.js"],"names":["Object","defineProperty","exports","value","enumerable","get","_path","default","_scope","_hub","visitors","_context","_interopRequireDefault","require","_interopRequireWildcard","t","cache","_getRequireWildcardCache","WeakMap","obj","__esModule","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","traverse","parent","opts","scope","state","parentPath","noScope","type","Error","VISITOR_KEYS","explode","node","_default","hasDenylistedType","path","stop","verify","cheap","enter","traverseFast","skipKeys","keys","context","visit","clearNode","removeProperties","delete","tree","hasType","denylistTypes","includes","denylist","SHOULD_SKIP","SHOULD_STOP","REMOVED","virtualTypes","_index","_cache","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","debug","buildDebug","NodePath","hub","this","contexts","_traverseFlags","container","listKey","data","isScope","val","create","def","undefined","msg","SyntaxError","buildError","visitor","validate","parts","inList","unshift","join","message","enabled","getPathLocation","code","v","targetNode","paths","Map","setup","assign","TYPES","typeKey","fn","TypeError","indexOf","push","virtualType","checkPath","clear","clearPath","clearScope","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","ReferencedIdentifier","types","isIdentifier","isJSXMemberExpression","isJSXIdentifier","react","isCompatTag","name","isReferenced","isMemberExpression","grandparent","isBinding","isStatement","isVariableDeclaration","isForXStatement","left","isForStatement","init","isReferencedIdentifier","isExpression","isBlockScoped","isVar","loc","isUser","isPure","isFlow","isImportDeclaration","importKind","isExportDeclaration","exportKind","isImportSpecifier","isObjectPattern","isObjectExpression","await","_renamer","_binding","globals","gatherNodeParts","isModuleDeclaration","isExportAllDeclaration","isExportNamedDeclaration","source","specifiers","length","isExportDefaultDeclaration","declaration","isModuleSpecifier","local","isLiteral","object","property","callee","properties","argument","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","For","FOR_INIT_KEYS","declar","getFunctionParent","getProgramParent","registerBinding","Declaration","registerDeclaration","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","isClassDeclaration","isFunctionDeclaration","binding","getBinding","reference","declarations","decl","getBindingIdentifiers","LabeledStatement","getBlockParent","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","bindings","CatchClause","Function","isFunctionExpression","NOT_LOCAL_BINDING","params","param","ClassExpression","uid","block","labels","inited","uids","crawling","cached","_parent","isKey","isMethod","generateUidIdentifier","cloneNode","identifier","generateUid","toIdentifier","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","defaultName","slice","generateUidBasedOnNode","isThisExpression","isSuper","constant","dontPush","isStatic","generateUidIdentifierBasedOnNode","kind","oldName","newName","rename","map","sep","repeat","console","log","violations","arrayLikeIsIterable","isGenericType","isArrayExpression","callExpression","memberExpression","helperName","args","numericLiteral","addHelper","getLabel","label","isLabeledStatement","registerLabel","specifier","unaryExpression","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","constantsOnly","isClass","superClass","body","isClassBody","method","isBinary","right","elements","elem","prop","computed","isProperty","isUnaryExpression","isTaggedTemplateExpression","matchesPattern","tag","quasi","isTemplateLiteral","expressions","isPureish","crawl","programParent","_exploded","typeVisitors","addGlobal","ref","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","getData","variableDeclaration","unshiftContainer","setData","declarator","variableDeclarator","pop","isFunctionParent","isBlockParent","kinds","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","hasOwnBinding","parentHasBinding","hasUid","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","builtin","Binding","referencePaths","referenced","clearValue","hasDeoptedValue","hasValue","TraversalContext","queue","priorityQueue","notPriority","trap","shouldVisit","visitQueue","visited","WeakSet","resync","pushContext","process","add","popContext","nodes","Array","isArray","visitMultiple","visitSingle","_helperSplitExportDeclaration","renameVisitor","bindingIdentifierEquals","skip","skipKey","skipAllButComputedMethodKey","Renamer","parentDeclar","maybeExportDeclar","find","isDeclaration","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","cases","forEach","c","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","findParent","callback","p","getStatementParent","isFile","getEarliestCommonAncestorFrom","getDeepestCommonAncestorFrom","deepest","ancestries","earliest","parentKey","filter","lastCommonIndex","lastCommon","minDepth","Infinity","ancestry","first","depthLoop","shouldMatch","getAncestry","isAncestor","maybeDescendant","isDescendant","maybeAncestor","inType","candidateTypes","getTypeAnnotation","typeAnnotation","_getTypeAnnotation","anyTypeAnnotation","isTypeAnnotation","isVariableDeclarator","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","voidTypeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","validParent","isBaseType","baseName","soft","_isBaseType","couldBeBaseType","isAnyTypeAnnotation","isUnionTypeAnnotation","type2","baseTypeStrictlyMatches","rightArg","isFlowBaseAnnotation","genericName","isGenericTypeAnnotation","isStringTypeAnnotation","isNumberTypeAnnotation","isBooleanTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isVoidTypeAnnotation","VariableDeclarator","_type","isCallExpression","ArrayExpression","TypeCastExpression","NewExpression","genericTypeAnnotation","TemplateLiteral","NUMBER_UNARY_OPERATORS","numberTypeAnnotation","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","booleanTypeAnnotation","BinaryExpression","NUMBER_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","unionTypeAnnotation","LogicalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ConditionalExpression","SequenceExpression","ParenthesizedExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","nullLiteralTypeAnnotation","RegExpLiteral","ObjectExpression","RestElement","ClassDeclaration","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","TaggedTemplateExpression","_infererReference","buildMatchMemberExpression","resolve","is","returnType","functionConstantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","concat","violation","getTypeAnnotationBindingConstantViolations","functions","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","target","typeofPath","typePath","BOOLEAN_NUMBER_BINARY_OPERATORS","typeValue","createTypeAnnotationBasedOnTypeof","isIfStatement","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","replaceWithMultiple","_pathCache$get","_verifyNodeList","inheritLeadingComments","inheritTrailingComments","insertAfter","requeue","remove","replaceWithSourceString","replacement","_parser","parse","err","_codeFrame","codeFrameColumns","start","line","column","replaceWith","removed","_index2","nodePath","isNodeType","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","expressionStatement","replaceExpressionWithStatements","oldNode","inheritsComments","removeComments","_replaceWith","setScope","_pathCache$get2","toSequenceExpression","functionParent","isParentAsync","isParentGenerator","arrowFunctionExpression","blockStatement","hoistVariablesVisitor","completionRecords","getCompletionRecords","isExpressionStatement","loop","generateDeclaredUidIdentifier","pushContainer","returnStatement","assignmentExpression","arrowFunctionToExpression","needToAwaitFunction","FUNCTION_TYPES","needToYieldFunction","awaitExpression","yieldExpression","replaceInline","_containerInsertAfter","VariableDeclaration","exprs","evaluateTruthy","res","evaluate","confident","deoptPath","seen","evaluateCached","deopt","VALID_CALLEES","INVALID_METHODS","existing","resolved","item","isSequenceExpression","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","evaluateQuasis","quasis","testResult","isExpressionWrapper","end","NaN","prefix","arg","arr","elems","elemValue","props","isObjectMethod","isSpreadElement","wasConfident","leftConfident","rightConfident","Math","pow","func","global","apply","_evaluate","raw","str","cooked","expr","String","toComputedKey","stringLiteral","bodyNode","statements","stringPath","arrowFunctionToShadowed","isArrowFunctionExpression","unwrapFunctionEnvironment","buildCodeFrameError","hoistFunctionEnvironment","allowInsertArrow","specCompliant","noNewArrows","thisBinding","checkBinding","objectExpression","thisExpression","_helperFunctionName","fnPath","thisEnvFn","isClassProperty","static","inConstructor","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","child","ClassProperty","superBinding","getSuperBinding","superCall","argumentsBinding","argumentsChild","argsRef","newTargetBinding","metaProperty","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","jsxIdentifier","assignmentPath","op","tmp","binaryExpression","isUpdateExpression","updateExpr","computedKey","sequenceExpression","isClassMethod","supers","argsBinding","restElement","super","spreadElement","propName","fnBody","argsList","valueIdent","cacheKey","ThisExpression","JSXIdentifier","isJSXOpeningElement","MemberExpression","MetaProperty","pattern","allowPartial","isnt","equals","isType","isFor","isCompletionRecord","allowInsideFunction","isStatementOrBlock","STATEMENT_OR_BLOCK_KEYS","referencesImport","moduleSource","importName","isOptionalMemberExpression","isImportDefaultSpecifier","isImportNamespaceSpecifier","imported","getSource","getCode","willIMaybeExecuteBefore","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","allStatus","executionOrderCheckedNodes","dangerous","_resolve","ret","isTypeCastExpression","targetKey","targetName","match","isNaN","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","isExecutionUncertain","maxIndex","_call","fns","then","isBlacklisted","isDenylisted","_this$opts$denylist","blacklist","shouldSkip","shouldStop","getScope","setContext","_resyncParent","_resyncList","_resyncKey","setKey","newContainer","_resyncRemoved","_markRemoved","_this$node","pathToQueue","maybeQueue","_getQueueContexts","_this$opts","_assertUnremoved","_removeFromScope","_callRemovalHooks","shareCommentsWithSiblings","_remove","removeBinding","_removalHooks","hooks","splice","updateSiblingKeys","self","isWhile","isSwitchCase","insertBefore","nodes_","isJSXElement","_containerInsertBefore","shouldInsertCurrentNode","_containerInsert","from","to","getSibling","assertExpression","temp","fromIndex","incrementBy","verifiedNodes","hoist","hoister","_hoister","run","referenceVisitor","breakOnScopePaths","mutableBinding","PathHoister","scopes","attachAfter","isCompatibleScope","_getAttachmentPath","targetScope","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","getCompatibleScopes","attachTo","getAttachmentPath","attached","children","jsxExpressionContainer","getOpposite","_getCompletionRecords","canHaveBreak","shouldPopulateBreak","inCaseClause","r","getPrevSibling","getNextSibling","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","split","_getKey","_getPattern","_","part","duplicates","getBindingIdentifierPaths","outerOnly","search","shift","_ids","getOuterBindingIdentifierPaths","addCompletionRecords","records","normalCompletionToBreak","completions","replaceBreakStatementInBreakCompletion","reachable","isBreakStatement","getStatementListCompletion","lastNormalCompletions","newContext","statementCompletions","some","isDoExpression","isTryStatement","caseCompletions","normalCompletions","breakCompletions","completionRecordForSwitch","BreakCompletion","NormalCompletion","trailing","trailingComments","leading","leadingComments","prev","next","hasPrev","Boolean","hasNext","addComments","addComment","content","comments","formatArgs","useColors","module","humanize","diff","color","index","lastC","save","namespaces","storage","setItem","removeItem","error","load","getItem","DEBUG","window","__nwjs","navigator","userAgent","toLowerCase","document","documentElement","style","WebkitAppearance","firebug","exception","table","parseInt","RegExp","$1","localStorage","localstorage","destroy","warned","warn","colors","formatters","j","JSON","stringify","env","createDebug","prevTime","enableOverride","curr","Number","Date","ms","coerce","format","formatter","logFn","selectColor","extend","configurable","delimiter","newDebug","toNamespace","regexp","toString","substring","stack","disable","names","skips","enable","len","substr","test","hash","charCodeAt","abs","s","m","h","d","w","y","plural","msAbs","n","isPlural","round","options","exec","parseFloat","isFinite","long","fmtLong","fmtShort","merge","states","wrapper","rootVisitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","nodeType","shouldIgnoreKey","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","aliases","FLIPPED_ALIAS_KEYS","deprecatedKey","DEPRECATED_KEYS","trace","alias","_verified","validateVisitorMethods","visitorKey","oldVisitor","newVisitor","newFn","arguments","dest","src","Hub"],"mappings":"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","file":"static/js/vendors-runtime-traverse.b0023fcf.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nexports.visitors = exports.default = void 0;\n\nvar _context = _interopRequireDefault(require(\"./context\"));\n\nvar visitors = _interopRequireWildcard(require(\"./visitors\"));\n\nexports.visitors = visitors;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar cache = _interopRequireWildcard(require(\"./cache\"));\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar _scope = _interopRequireDefault(require(\"./scope\"));\n\nvar _hub = _interopRequireDefault(require(\"./hub\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction traverse(parent, opts = {}, scope, state, parentPath) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!t.VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\nvar _default = traverse;\nexports.default = _default;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./lib/virtual-types\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _scope = _interopRequireDefault(require(\"../scope\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nvar _generator = _interopRequireDefault(require(\"@babel/generator\"));\n\nvar NodePath_ancestry = _interopRequireWildcard(require(\"./ancestry\"));\n\nvar NodePath_inference = _interopRequireWildcard(require(\"./inference\"));\n\nvar NodePath_replacement = _interopRequireWildcard(require(\"./replacement\"));\n\nvar NodePath_evaluation = _interopRequireWildcard(require(\"./evaluation\"));\n\nvar NodePath_conversion = _interopRequireWildcard(require(\"./conversion\"));\n\nvar NodePath_introspection = _interopRequireWildcard(require(\"./introspection\"));\n\nvar NodePath_context = _interopRequireWildcard(require(\"./context\"));\n\nvar NodePath_removal = _interopRequireWildcard(require(\"./removal\"));\n\nvar NodePath_modification = _interopRequireWildcard(require(\"./modification\"));\n\nvar NodePath_family = _interopRequireWildcard(require(\"./family\"));\n\nvar NodePath_comments = _interopRequireWildcard(require(\"./comments\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst buildDebug = require(\"debug\");\n\nconst debug = buildDebug(\"babel\");\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    t.validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _binding = _interopRequireDefault(require(\"./binding\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst globals = require(\"globals\");\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if ((t.isExportAllDeclaration(node) || t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((t.isExportDefaultDeclaration(node) || t.isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (t.isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst testing = process.env.NODE_ENV === \"test\";\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys != null && keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.trap) {\n      throw new Error(\"Infinite cycle detected\");\n    }\n\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n\n      if (testing && queue.length >= 10000) {\n        this.trap = true;\n      }\n\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = _interopRequireDefault(require(\"../binding\"));\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = t.VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = t.VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType(...candidateTypes) {\n  let path = this;\n\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = _interopRequireWildcard(require(\"./inferers\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) != null && _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t.isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n\n  return false;\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _infererReference = _interopRequireDefault(require(\"./inferer-reference\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return t.stringTypeAnnotation();\n    }\n\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return t.numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return t.booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return t.nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nconst isArrayFrom = t.buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = t.buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = t.buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = t.buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return t.arrayTypeAnnotation(t.stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return t.arrayTypeAnnotation(t.anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = _interopRequireDefault(require(\"./index\"));\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst hoistVariablesVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  VariableDeclaration(path) {\n    if (path.node.kind !== \"var\") return;\n    const bindings = path.getBindingIdentifiers();\n\n    for (const key of Object.keys(bindings)) {\n      path.scope.push({\n        id: bindings[key]\n      });\n    }\n\n    const exprs = [];\n\n    for (const declar of path.node.declarations) {\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    path.replaceWithMultiple(exprs);\n  }\n\n};\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.is(\"generator\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  this.traverse(hoistVariablesVisitor);\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        const callee = this.get(\"callee\");\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  const callee = this.get(\"callee\");\n  callee.arrowFunctionToExpression();\n\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES);\n\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get(\"callee.body\").node, \"YieldExpression\", t.FUNCTION_TYPES);\n\n  if (needToAwaitFunction) {\n    callee.set(\"async\", true);\n\n    if (!needToYieldFunction) {\n      this.replaceWith(t.awaitExpression(this.node));\n    }\n  }\n\n  if (needToYieldFunction) {\n    callee.set(\"generator\", true);\n    this.replaceWith(t.yieldExpression(this.node, true));\n  }\n\n  return callee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t.returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t.expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t.blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const thisBinding = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t.objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(this.hub.addHelper(\"newArrowCheck\"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));\n    this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t.identifier(\"bind\")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  const thisEnvFn = fnPath.findParent(p => {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = t.identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => t.identifier(\"arguments\"));\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = t.identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => t.metaProperty(t.identifier(\"new\"), t.identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = t.identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = t.callExpression(t.identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", t.thisExpression());\n        superProp.replaceWith(t.memberExpression(call, t.identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [t.assignmentExpression(\"=\", tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression(\"=\", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression(\"+\", t.identifier(tmp.name), t.numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t.identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(t.sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, t.assignmentExpression(\"=\", t.identifier(thisBinding), t.identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = t.memberExpression(t.super(), t.identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t.assignmentExpression(\"=\", fnBody, t.identifier(valueIdent.name));\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.is = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction matchesPattern(pattern, allowPartial) {\n  return t.matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) {\n    if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? t.isStringLiteral(this.node.property, {\n      value: importName\n    }) : this.node.property.name === importName)) {\n      const object = this.get(\"object\");\n      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, \"*\");\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && t.isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = t.VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!t.isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    const body = path.isFunction() ? path.node.body : path.node;\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = require(\"./index\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.shouldSkip || this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  if (this.key === \"key\" && path.isMethod()) path = path.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nexports._removeFromScope = _removeFromScope;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = _interopRequireWildcard(require(\"./index\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = _interopRequireDefault(require(\"./lib/hoister\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        t.assertExpression(node);\n        this.replaceWith(t.callExpression(t.arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\n\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, records, context) {\n  if (path) return records.concat(_getCompletionRecords(path, context));\n  return records;\n}\n\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n\n    const caseCompletions = _getCompletionRecords(casePath, context);\n\n    const normalCompletions = [];\n    const breakCompletions = [];\n\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n\n    records = records.concat(breakCompletions);\n  }\n\n  records = records.concat(lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(t.unaryExpression(\"void\", t.numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(paths, context) {\n  let completions = [];\n\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n          newContext.shouldPopulateBreak = true;\n        } else {\n        newContext.shouldPopulateBreak = false;\n      }\n\n      const statementCompletions = _getCompletionRecords(path, newContext);\n\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions = completions.concat(lastNormalCompletions);\n\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions = completions.concat(statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions = completions.concat(statementCompletions);\n\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n\n        break;\n      }\n\n      if (i === paths.length - 1) {\n        completions = completions.concat(statementCompletions);\n      } else {\n        completions = completions.concat(statementCompletions.filter(c => c.type === BREAK_COMPLETION));\n        lastNormalCompletions = statementCompletions.filter(c => c.type === NORMAL_COMPLETION);\n      }\n    }\n  } else if (paths.length) {\n    completions = completions.concat(_getCompletionRecords(paths[paths.length - 1], context));\n  }\n\n  return completions;\n}\n\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    records = addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    records = records.concat(getStatementListCompletion(path.get(\"body\"), context));\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    records = addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    records = completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    records = records.concat(getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    }));\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n\n  return records.map(r => r.path);\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  t.addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  t.addComments(this.node, type, comments);\n}","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./path/lib/virtual-types\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;"],"sourceRoot":""}